# 排序算法

## 1. 冒泡排序  Bubble Sort

以`升序`为例, 从左至右, 相邻元素比较, 大的交换位置, 逐步右移到最大位置

如果数据如下

```java
int[] array = {99, 88, 3, 110, 4, 20};
```

冒泡排序:

第一轮. 共比较 5 次

```java
//第一次比较: 比较 99, 88. 发现 88 < 99, 则 99 与 88 交换位置
88, [99], 3, 110, 4, 20

//第二次比较: 比较 99,3. 发现 3 < 99, 则 99 与 3 交换位置
88, 3, [99], 110, 4, 20

//第三次比较: 比较 99, 110. 发现 110>99, 则不处理
88, 3, 99, [110], 4, 20

//第四次比较: 比较 110,4. 发现 4 <110, 则 110 与 4 交换位置
88, 3, 99, 4, [110], 20

//第五次比较: 比较 110,20. 发现 20<110, 则 110 与 20 交换位置
88, 3, 99, 4, 20, [110]
```

第二轮. `88, 3, 99, 4, 20, 110`. 比较四次

```java
3, [88], 99, 4, 20, 110
3, 88, 99, 4, 20, 110
3, 88, 4, [99], 20, 110
3, 88, 4, 20, [99], 110
```

依次类推, 第三轮. `3, 88, 4, 20, [99], 110`

```java
3, 88, 4, 20, 99, 110
3, 4, [88], 20, 99, 110
3, 4, 20, [88], 99, 110
```

第四轮: `3, 4, 20, 88, 99, 110`

```java
3, 4, 20, 88, 99, 110
```

代码如下:

```java
Integer[] array = {99, 88, 3, 110, 4, 20}

static void bubbleSort(Integer[] array) {
   for (int end = array.length-1; end >0 ; end--) {
       for (int begin = 1; begin <= end; begin++) {
           if (array[begin] < array[begin-1]) {
               int tmp = array[begin];
               array[begin] = array[begin-1];
               array[begin-1] = tmp;
           }
       }
   }
}
```

冒泡排序优化

```java
static void bubbleSort2(Integer[] array) {
   for (int end = array.length-1; end >0 ; end--) {
       int sortedIndex = 1;    // 初始值在数组完全有序的时候有用
       for (int beigin = 1; beigin <= end; beigin++) {
           if (array[beigin] < array[beigin-1]) {
               int tmp = array[beigin];
               array[beigin] = array[beigin - 1];
               array[beigin - 1] = tmp;
               sortedIndex = beigin;
           }
       }
       end = sortedIndex;
   }
}
```

## 2.选择排序  Selection Sort

从头找出最大的元素, 与最末尾元素交换位置.

忽略最尾最大元素, 重头重新执行. 一直循环
   
          
代码实现:

```java
static void selectionSort(Integer[] array) {
   for (int end = array.length-1; end >0 ; end--) {
       // 最大值索引
       int maxIndex = 0;
       for (int begin = 1; begin <= end ; begin++) {
           if (array[maxIndex] <= array[begin]) {
               maxIndex = begin;
           }
       }

       int tmp = array[maxIndex];
       array[maxIndex] = array[end];
       array[end] = tmp;
   }
}
```

## 3. 堆排序  Heap Sort


## 4. 插入排序 Insertion Sort

|44, 51, 61, 81, 91, 96, | 52, 53, 71, 18, 32, 60, 5|
|有序部分                 | 无序部分                   |

执行过程中, 插入排序会将序列分为 2 个部分.
- 头部是已经排好序的, 尾部是待排序的

从头开始扫描每一个元素. 每当扫描到一个元素, 就将它插入到头部合适的位置, 使得头部数据依然保持有序.

```java
for (int beigin = 1; beigin < array.length; beigin++) {
  int curIndex = beigin;
   while(curIndex > 0 && cmp(curIndex, curIndex-1) < 0) {
       swap(beigin, beigin-1);
       curIndex--;
   }
}
```

#### 插入排序 - 逆序对 (Inversion)

逆序对:

数组 <2,3,8,6,1> 的逆序对位: <2,1> <3,1> <8,1> <8,6> <6,1>, 共 5 个逆序对.

- 插入排序`时间复杂度`与逆序对的数量成正比, 逆序对数量越多, 插入排序的时间复杂度越高

- 最坏, 平均时间复杂度: O(n²) (降序的时候, 每次都要比, 1+2+3+...+n)
- 最好时间复杂度  O(n) (基本都是升序的时候, 只是左右做一次比较)
- 空间复杂度 O(1)
- 属于稳定排序

#### 插入排序优化

将 `交换` 改为 `挪动`.


```java
for (int beigin = 1; beigin < array.length; beigin++) {
  int cur = beigin;
  E v = array[cur];   // 取出备份
  while (cur > 0 && cmp(v, array[cur - 1]) < 0) {
      array[cur] = array[cur - 1];    // 元素覆盖
      cur--;
  }
  array[cur] = v; // 赋值
}
```

## 5. 二分搜索 Binary Search


如果是无序数组, 从第 0 个位置开始遍历搜索, 平均时间复杂度 O(n);

如果是有序数组, 用二分搜索, 最坏时间复杂度 O(logn).


| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 15 | 17 | 20 | 28 | 31 | 45 | 56 | 59 | 66 | 88 |

假如查找 56.

- 先取中间值. 索引 4. 28 比较, 发现 56 > 28. 则再右半部分找
- 索引 4 到索引 9 取中间值, 索引 6 45. 发现 56 > 45, 则继续右半部分找
- 依次类推

## 6. 归并排序 Merge Sort

- 不断地将当前序列平均分割成 2 个子序列, 直到不能再分割(序列中只剩一个元素)
- 不断地将 2 个子序列合并成一个有序序列, 直到最终只剩下一个有序序列

![](media/16756886216599/16759117214529.jpg)


    
#### 归并排序 - 复杂度

最好, 最坏, 平均时间复杂度都是 O(nlogn).

空间复杂度 O(n/2 + logn) = O(n)

## 常见的递推式与复杂度

T(n) 表示时间大约为 T(n)


| 递推式 | 复杂度 |
| --- | --- |
| T(n) = T(n/2) + O(1) | O(logn) |
| T(n) = T(n-1) +O(1) | O(n) |
| T(n) = T(n/2) + O(n) | O(n) |
| T(n) = 2 * T(n/2) + O(1) | O(n) |
| T(n) = 2 * T(n/2) + O(n) | O(nlogn) |
| T(n) = T(n-1) + O(n) | O(n²) |
| T(n) = 2 * T(n-1) + O(1) | O(2^n) |
| T(n) = 2 * T(n-1) + O(n) | O(2^n) |

## 7. 快速排序

1. 从序列中选择一个`轴点`元素 (pivot)

- 假设每次选择 0 位置的元素作为轴点元素

2. 利用 pivot 将序列分割成 2 个子序列

- 将小于 pivot 的元素放在 pivot 前面 (左侧)
- 将大于 pivot 的元素放在 pivot 后面 (右侧)
- 将等于 pivot 的元素放哪边都可以

3. 对子序列进行 1, 2 操作

- 直到不能再分割为止 (子序列只剩下一个元素)


| 6 | 11 | 8 | 2 | 9 | 4 | 1 | 5 | 7 | 10 | 3 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

假设第一次取 6 为轴点.

- 那么分割后序列如下, 比 6 小的都在左侧, 比 6 大的都在右侧

          
| 3 | 5 | 1 | 2 | 4 | 6 | 9 | 8 | 7 | 10 | 11 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |


- 那么此时 pivot=6 有 2 个子序列, 3 ~ 4, 9 ~ 11. 接着对子序列分割
- 假设取左侧子序列 3 作为 pivot. 右侧子序列取 9 作为 pivot, 分割后如下:


| 2 | 1 | 3 | 5 | 4 | 6 | 7 | 8 | 9 | 10 | 11 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

- 那么此时子序列如下: 2~1, 5~4, 7~8, 10~11. 接着对这些子序列进行分割
- 分别取 pivot=2, pivot=5, pivot=7, pivot=10, 分割后如下


| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

至此分割结束. 排序完成.

#### 快速排序的本质

逐渐将每一个元素都转换成轴点元素.

#### 快速排序 - 轴点构造

| begin |  |  |  |  |  |  |  | end |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 6a | 8a | 8b | 2 | 6b | 4 | 9 | 5 | 7 |

取出 begin 位置元素作为轴点元素, 6a, 备份 6a. 最后会用到, 覆盖元素.

1. 先从 end 往左扫描.

- 第一次取 7 和轴点元素 6a 比较,发现 7>6. 那么 7 应该是放到 6a 的右边. 目前就是在右边, 则 end--; end 此时在元素 5 上.

| begin |  |  |  |  |  |  | end |   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 6a | 8a | 8b | 2 | 6b | 4 | 9 | 5 | 7 |

2. 继续从 end 往左扫描

- 元素 5 和 6a 比较, 5 < 6, 则 5 应该在 6 左边. 
- end 不动. 5 直接覆盖 begin 位置元素 6a. begin++. 此时 begin 在 8a 元素索引

| | begin |  |  |  |  |  | end |   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 5 | 8a | 8b | 2 | 6b | 4 | 9 | 5 | 7 |

3. 上面找到元素比轴点元素 6a 小, 放到左边后, 扫描方向改变, 从 begin 开始往右扫描

- 取出 begin 位置元素, 8a. 发现比轴点元素 6a 大. 则放到右侧
- 上面 end 元素 5, 直接覆盖掉, 然后 end--;

| | begin |  |  |  |  | end | |   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 5 | 8a | 8b | 2 | 6b | 4 | 9 | 8a | 7 |

4. 继续从 end, 比较 9 和 6a. end--, 元素不动

| | begin |  |  |  | end | | |   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 5 | 8a | 8b | 2 | 6b | 4 | 9 | 8a | 7 |

5. 继续从 end 扫描, 比较 4 和 6a. 4<6, 放到左侧,然后从 begin 扫描. begin++

| | | begin |  |  | end | | |   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 5 | 4 | 8b | 2 | 6b | 4 | 9 | 8a | 7 |

6. 后面依次类推...序列如下:

| | | begin |  | end | | | |   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 5 | 4 | 8b | 2 | 6b | 8b | 9 | 8a | 7 |

7. 6b 和 6a 相等, 此时按小于等于处理, 放到左侧

| | | | begin | end | | | |   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 5 | 4 | 6b | 2 | 6b | 8b | 9 | 8a | 7 |

8. 剩一个 2, 元素不动, begin++. begin 和 end 会和, 结束! 将 6b 位置元素, 覆盖成之前备份的轴点元素 6a

| | | | | begin end | | | |   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 5 | 4 | 6b | 2 | 6a | 8b | 9 | 8a | 7 |

    

#### 快速排序 - 时间复杂度

最好情况 (轴点左右两侧元素分布均匀): 

- T(n) = 2 * T(n/2) + O(n) = O(nlogn)

最坏情况 (轴点左右两侧元素分布极不均匀):

- T(n) = T(n-1) + O(n) = O(n²)

为了降低最坏情况出现概率, 一般做法是:

- 随机选择轴点元素

由于递归调用原因, 空间复杂度 : O(logn)

快速排序, 属于不稳定排序.

## 8. 希尔排序 Shell Sort

把序列看做是一个`矩阵`, 分成 `m` 列, 逐列进行排序.

- `m`从某个整数逐渐减为 1
- 当`m`为 1 时, 整个序列将完全有序.

因此, 希尔排序也叫做`递减增量排序`.

矩阵的列数取决于`步长序列 (step sequence)`

- 如果步长序列为 {1, 4, 19 , 41, 109,...} 就代表依次分成 109 列, 41 列, 19 列, 4 列, 1 列.
- 不同的步长序列, 执行效率不同


希尔本人给出的步长序列是 `n/2^k`

- 如 n=16 时, 步长序列是 {1, 2, 4, 8}

#### 排序思路


| 16 | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

##### 分成 8 列排序:

| 16 | 15 | 14 | 13 | 12 | 11 | 10 | 9 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |

排序结果:

| 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 16 | 15 | 14 | 13 | 12 | 11 | 10 | 9 |


结果:

| 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 16 | 15 | 14 | 13 | 12 | 11 | 10 | 9 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

##### 分成 4 列排序


| 16 | 15 | 14 | 13 |
| --- | --- | --- | --- |
| 12 | 11 | 10 | 9 |
| 8 | 7 | 6 | 5 |
| 4 | 3 | 2 | 1 |

排序结果:


| 4 | 3 | 2 | 1 |
| --- | --- | --- | --- |
| 8 | 7 | 6 | 5 |
| 12 | 11 | 10 | 9 |
| 16 | 15 | 14 | 13 |

结果:


| 4 | 3 | 2 | 1 | 8 | 7 | 6 | 5 | 12 | 11 | 10 | 9 | 16 | 15 | 14 | 13 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

#### 以此类推, 直到分成 1 列

- 可以看出, 从 8 列到 1 列的过程中, `逆序对`的数量在逐渐减少
- 因此希尔排序底层一般使用`插入排序`对每一列进行排序.

#### 步长序列

希尔本人给出的步长序列, 最坏情况时间复杂度 O(n²).

目前已知最好的步长序列, 最坏情况时间复杂度 O(n^(4/3))

- 如果 k 是偶数, 公式

```c
9(2^k - 2^(k/2)) + 1
```

- 如果 k 是奇数, 公式

```c
8*2^k - 6*2^((k+1)/2) + 1
```

## 8. 计数排序  Counting Sort

基于比较的排序: 平均时间复杂度目前最低是 O(nlogn)

- 冒泡
- 选择
- 插入
- 归并
- 快速
- 希尔
- 堆排序

计数排序, 桶排序, 基数排序都不是基于比较的排序.

- 是典型的空间换时间, 在某些时候, 复杂度可以比 O(nlogn) 更低

计数排序:

- 统计每个整个在序列中出现的次数, 进而推导出每个整数在有序序列中的索引.

## 9. 基数排序 Radix Sort

非常适合用于整数排序(尤其是非负整数).

依次对个位数, 十位数, 百位数, 千位数, 万位数..进行排序

## 10. 桶排序 Bucket Sort

- 创建一定数量的桶, (比如用数组, 链表作为桶)
- 按照一定的规则(不同类型的数据, 规则不同), 将序列中的元素均匀分配到对应的桶.
- 分别对每个桶进行单独排序
- 将所有非空桶的元素合并成有序序列

